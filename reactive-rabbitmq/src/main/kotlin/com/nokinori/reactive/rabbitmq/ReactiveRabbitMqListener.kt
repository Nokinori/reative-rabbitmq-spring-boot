package com.nokinori.reactive.rabbitmq

import com.nokinori.reactive.rabbitmq.container.SimpleReactiveMessageContainer
import com.nokinori.reactive.rabbitmq.container.core.AckMode
import com.nokinori.reactive.rabbitmq.container.core.ReactiveMessageContainer
import com.nokinori.reactive.rabbitmq.container.core.ReactiveMessageListener
import com.nokinori.reactive.rabbitmq.container.listener.*
import com.nokinori.reactive.rabbitmq.converter.ReactiveMessageConverter
import com.nokinori.reactive.rabbitmq.decorator.AbstractReactiveRabbitMqHooks
import com.nokinori.reactive.rabbitmq.decorator.ReactiveRabbitMqHooks
import org.reactivestreams.Publisher
import reactor.core.publisher.Mono
import reactor.rabbitmq.ConsumeOptions
import reactor.rabbitmq.Receiver

/**
 * Provides builder style api to create different [ReactiveMessageListener].
 */
object ReactiveRabbitMqListener {
    fun builder() = ContainerSpecification()

    /**
     * Describes the container that will be created by [build].
     */
    open class ContainerSpecification {
        protected open lateinit var receiver: Receiver
        protected open var queues: MutableList<String> = mutableListOf()
        protected open var listener: ReactiveMessageListener? = null
        protected open var consumeOptions: ConsumeOptions = ConsumeOptions()
        protected open var reactiveRabbitMqHooks: ReactiveRabbitMqHooks = AbstractReactiveRabbitMqHooks()
        protected open var eventHandler: () -> Mono<*> = { Mono.empty<Void>() }
        protected open var delayPublisher: Publisher<*> = Mono.empty<Void>()
        protected open var ackMode: AckMode = AckMode.AUTO

        /**
         * Reactive receiver to consume messages [Receiver].
         */
        fun receiver(receiver: Receiver) = apply { this.receiver = receiver }

        /**
         * Queue to consume.
         */
        fun queue(queue: String) = apply { queues.add(queue) }

        /**
         * Queues list to consume.
         */
        fun queues(queues: List<String>) = apply { this.queues = queues.toMutableList() }

        /**
         * [ReactiveMessageListener] to use instead of autogenerated.
         * If not specified, the listener will be resolved automatically by [resolveListener].
         */
        fun listener(listener: ReactiveMessageListener) = apply { this.listener = listener }

        /**
         * [ConsumeOptions] to use after creation in container.
         */
        fun consumeOptions(consumeOptions: ConsumeOptions) = apply { this.consumeOptions = consumeOptions }

        /**
         * [ReactiveRabbitMqHooks] to use after creation in container.
         */
        fun hooks(hooks: ReactiveRabbitMqHooks) = apply { this.reactiveRabbitMqHooks = hooks }

        /**
         * [AckMode] Acknowledge mode for container.
         */
        fun ackMode(ackMode: AckMode) = apply { this.ackMode = ackMode }

        /**
         * [Publisher] that will be executed before container starts.
         */
        fun delayBeforeContainerStart(delayPublisher: Publisher<*>) = apply { this.delayPublisher = delayPublisher }

        /**
         * Lambda with handler of empty message.
         */
        fun eventHandler(eventHandler: () -> Mono<*>) = apply {
            this.eventHandler = eventHandler
        }

        /**
         * Lambda with typed handler. Switches to [TypedContainerSpecification]
         */
        inline fun <reified T> eventHandler(noinline eventHandler2: (T) -> Mono<*>) =
            eventHandler(eventHandler2, T::class.java)

        /**
         * Lambda with typed handler. Switches to [TypedContainerSpecification]
         */
        fun <T> eventHandler(eventHandler: (T) -> Mono<*>, eventType: Class<T>) = TypedContainerSpecification(
            receiver,
            queues,
            listener,
            consumeOptions,
            ackMode,
            reactiveRabbitMqHooks,
            delayPublisher,
            eventHandler,
            eventType
        )

        /**
         * Create container with following specification.
         * If [listener] wasn't specified then automatic receiver would be used [resolveListener].
         */
        fun build(): ReactiveMessageContainer {
            validation()
            return SimpleReactiveMessageContainer(
                receiver,
                queues,
                resolveListener(),
                consumeOptions,
                ackMode
            )
                .delayBeforeStartFor(delayPublisher)
        }

        /**
         * Returns specified listener or instance of [AutoAcknowledgmentReactiveMessageListener].
         */
        protected open fun resolveListener() =
            listener ?: AutoAcknowledgmentReactiveMessageListener(eventHandler, reactiveRabbitMqHooks)

        private fun validation() {
            when {
                queues.isEmpty() -> throw IllegalStateException("Queues must not be empty")
            }
        }
    }

    /**
     * Describes the container that will be created by [build].
     * This specification provide possibility to consume messages.
     * Convert it with specified [ReactiveMessageConverter] and provide instance of [T].
     * Depends on [retryConfig], [dlqConfig] different type of container will be created.
     *
     * If [retryConfig] is specified then [TypedRetryableManualAcknowledgmentReactiveMessageListener] is created.
     * If [dlqConfig] is specified then Dead Letter Queue will be created. It works only with [retryConfig]!
     */
    class TypedContainerSpecification<T>(
        override var receiver: Receiver,
        override var queues: MutableList<String>,
        override var listener: ReactiveMessageListener?,
        override var consumeOptions: ConsumeOptions,
        override var ackMode: AckMode,
        override var reactiveRabbitMqHooks: ReactiveRabbitMqHooks,
        override var delayPublisher: Publisher<*>,
        private var eventHandlerWithType: (T) -> Mono<*>,
        private var eventType: Class<T>
    ) : ContainerSpecification() {
        private lateinit var messageConverter: ReactiveMessageConverter
        private var retryConfig: RetryConfig? = null
        private var dlqConfig: DLQConfig? = null
        private var reactiveRabbitMqSender: ReactiveRabbitMqSender? = null

        /**
         * [ReactiveMessageConverter] to convert messages.
         */
        fun messageConverter(messageConverter: ReactiveMessageConverter) =
            apply { this.messageConverter = messageConverter }

        /**
         * Sender that will be used in retries.
         */
        fun sender(reactiveRabbitMqSender: ReactiveRabbitMqSender) =
            apply { this.reactiveRabbitMqSender = reactiveRabbitMqSender }

        /**
         * [RetryConfig] for retries.
         */
        fun retryConfig(retryConfig: RetryConfig) = apply { this.retryConfig = retryConfig }

        /**
         * [DLQConfig] for retries.
         */
        fun dlq(dlqConfig: DLQConfig?) = apply { this.dlqConfig = dlqConfig }

        /**
         * Returns specified listener or instance of [ReactiveMessageListener] that works with specified type [T].
         * Listener is resolved by [ackMode] and [retryConfig].
         */
        override fun resolveListener() = listener ?: when {
            ackMode == AckMode.AUTO || ackMode == AckMode.NONE ->
                //no ack in inner logic
                TypedAutoAcknowledgmentReactiveMessageListener(
                    eventHandlerWithType,
                    eventType,
                    messageConverter,
                    reactiveRabbitMqHooks
                )
            ackMode == AckMode.MANUAL && retryConfig != null && reactiveRabbitMqSender != null ->
                TypedRetryableManualAcknowledgmentReactiveMessageListener(
                    eventHandlerWithType,
                    eventType,
                    messageConverter,
                    retryConfig!!,
                    reactiveRabbitMqSender!!,
                    reactiveRabbitMqHooks,
                    dlqConfig
                )
            ackMode == AckMode.MANUAL ->
                TypedManualAcknowledgmentReactiveMessageListener(
                    eventHandlerWithType,
                    eventType,
                    messageConverter,
                    reactiveRabbitMqHooks
                )
            else -> throw IllegalStateException("Listener can't be resolved")
        }
    }
}